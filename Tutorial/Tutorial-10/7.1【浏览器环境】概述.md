### 7.1 概述
[教程地址：7.1 概述](http://javascript.ruanyifeng.com/bom/engine.html)

---
### 目录
```
1. JavaScript代码嵌入网页的方法
   1.1 script标签：代码嵌入网页
   1.2 script标签：加载外部脚本
   1.3 事件属性
   1.4 URL协议
2. script标签
   2.1 工作原理
   2.2 defer属性
   2.3 async属性
   2.4 脚本的动态加载
   2.5 加载使用的协议
3. 浏览器的组成
   3.1 渲染引擎
   3.2 重流和重绘
   3.3 JavaScript引擎
4. 参考链接
```

---
### 1. JavaScript代码嵌入网页的方法
- JavaScript代码只有嵌入网页，才能在用户浏览器网页时运行
- 网页中嵌入JavaScript代码，主要有四种方法
  *   `<script>`标签：代码嵌入网页
  *   `<script>`标签：加载外部脚本
  *   事件属性：代码写入HTML元素的事件处理属性，比如`onclick`或者`onmouseover`
  *   URL协议：URL支持以`javascript:`协议的方式，执行JavaScript代码

#### 1.1  script标签：代码嵌入网页
- 通过`<script>`标签，可以直接将JavaScript代码嵌入网页
- `<script>`标签有一个`type`属性，用来指定脚本类型。对JavaScript脚本来说，`type`属性可以设为两种值
  *   `text/javascript`：这是默认值，也是历史上一贯设定的值。如果你省略`type`属性，默认就是这个值。对于老式浏览器，设为这个值比较好。
  *   `application/javascript`：对于较新的浏览器，建议设为这个值。

- 如果`type`属性的值，浏览器不认识，那么它不会执行其中的代码。利用这一点，可以在`<script>`标签之中嵌入任意的文本内容，然后加上一个浏览器不认识的`type`属性即可,但是，这个`<script>`节点依然存在于DOM之中，可以使用`<script>`节点的`text`属性读出它的内容

#### 1.2  script标签：加载外部脚本
- `<script>`标签也可以指定加载外部的脚本文件,如果脚本文件使用了非英语字符，还应该注明编码
- 为了防止攻击者篡改外部脚本，`script`标签允许设置一个`integrity`属性，写入该外部脚本的Hash签名，用来验证脚本的一致性

#### 1.3 事件属性
- 某些HTML元素的事件属性（比如`onclick`和`onmouseover`），可以写入JavaScript代码。当指定事件发生时，就会调用这些代码

#### 1.4  URL协议
- URL支持`javascript:`协议，调用这个URL时，就会执行JavaScript代码
- 浏览器的地址栏也可以执行`javascipt:`协议。将`javascript:alert('Hello')`放入地址栏，按回车键，就会跳出提示框
- `javascript:`协议的常见用途是书签脚本Bookmarklet。由于浏览器的书签保存的是一个网址，所以`javascript:`网址也可以保存在里面，用户选择这个书签的时候，就会在当前页面执行这个脚本

---
### 2.  script标签

#### 2.1  工作原理
- 浏览器加载JavaScript脚本，主要通过`<script>`标签完成。正常的网页加载流程是这样的
1.  浏览器一边下载HTML网页，一边开始解析
2.  解析过程中，发现`<script>`标签
3.  暂停解析，网页渲染的控制权转交给JavaScript引擎
4.  如果`<script>`标签引用了外部脚本，就下载该脚本，否则就直接执行
5.  执行完毕，控制权交还渲染引擎，恢复往下解析HTML网页

- 加载外部脚本时，浏览器会暂停页面渲染，等待脚本下载并执行完成后，再继续渲染。原因是JavaScript可以修改DOM（比如使用`document.write`方法），所以必须把控制权让给它，否则会导致复杂的线程竞赛的问题
- 如果外部脚本加载时间很长（比如一直无法完成下载），就会造成网页长时间失去响应，浏览器就会呈现“假死”状态，这被称为“阻塞效应”
- 为了避免这种情况，较好的做法是将`<script>`标签都放在页面底部，而不是头部。这样即使遇到脚本失去响应，网页主体的渲染也已经完成了，用户至少可以看到内容，而不是面对一张空白的页面
- 如果某些脚本代码非常重要，一定要放在页面头部的话，最好直接将代码嵌入页面，而不是连接外部脚本文件，这样能缩短加载时间
- 将脚本文件都放在网页尾部加载，还有一个好处。在DOM结构生成之前就调用DOM，JavaScript会报错，如果脚本都在网页尾部加载，就不存在这个问题，因为这时DOM肯定已经生成了
-  脚本的执行顺序由它们在页面中的出现顺序决定，这是为了保证脚本之间的依赖关系不受到破坏。当然，加载这两个脚本都会产生“阻塞效应”，必须等到它们都加载完成，浏览器才会继续页面渲染

#### 2.2 defer属性
- 为了解决脚本文件下载阻塞网页渲染的问题，一个方法是加入`defer`属性
- `defer`的运行流程如下
1.  浏览器开始解析HTML网页
2.  解析过程中，发现带有`defer`属性的`script`标签
3.  浏览器继续往下解析HTML网页，同时并行下载`script`标签中的外部脚本
4.  浏览器完成解析HTML网页，此时再执行下载的脚本

- 对于内置而不是加载外部脚本的`script`标签，以及动态生成的`script`标签，`defer`属性不起作用。另外，使用`defer`加载的外部脚本不应该使用`document.write`方法

#### 2.3 async属性
- 解决“阻塞效应”的另一个方法是加入`async`属性
- `async`属性的作用是，使用另一个进程下载脚本，下载时不会阻塞渲染
1.  浏览器开始解析HTML网页
2.  解析过程中，发现带有`async`属性的`script`标签
3.  浏览器继续往下解析HTML网页，同时并行下载`script`标签中的外部脚本
4.  脚本下载完成，浏览器暂停解析HTML网页，开始执行下载的脚本
5.  脚本执行完毕，浏览器恢复解析HTML网页

- `async`属性可以保证脚本下载的同时，浏览器继续渲染。需要注意的是，一旦采用这个属性，就无法保证脚本的执行顺序。哪个脚本先下载结束，就先执行那个脚本。另外，使用`async`属性的脚本文件中，不应该使用`document.write`方法
- `defer`属性和`async`属性到底应该使用哪一个？
- 一般来说，如果脚本之间没有依赖关系，就使用`async`属性，如果脚本之间有依赖关系，就使用`defer`属性。如果同时使用`async`和`defer`属性，后者不起作用，浏览器行为由`async`属性决定

#### 2.4  脚本的动态加载
- 除了静态的`script`标签，还可以动态生成`script`标签，然后加入页面，从而实现脚本的动态加载
- 这种方法的好处是，动态生成的`script`标签不会阻塞页面渲染，也就不会造成浏览器假死。但是问题在于，这种方法无法保证脚本的执行顺序，哪个脚本文件先下载完成，就先执行哪个
- 如果想避免这个问题，可以设置async属性为`false`
- 此外，动态嵌入还有一个地方需要注意。动态嵌入必须等待CSS文件加载完成后，才会去下载外部脚本文件。静态加载就不存在这个问题，`script`标签指定的外部脚本文件，都是与CSS文件同时并发下载的

#### 2.5 加载使用的协议
- 如果不指定协议，浏览器默认采用HTTP协议下载
- 但是有时我们会希望，根据页面本身的协议来决定加载协议，这时可以采用下面的写法

```
<script src="//example.js"></script>
```

---
### 3. 浏览器的组成
- 浏览器的核心是两部分：渲染引擎和JavaScript解释器（又称JavaScript引擎）

#### 3.1 渲染引擎
- 渲染引擎的主要作用是，将网页代码渲染为用户视觉可以感知的平面文档
- 不同的浏览器有不同的渲染引擎
  *   Firefox：Gecko引擎
  *   Safari：WebKit引擎
  *   Chrome：Blink引擎
  *   IE: Trident引擎
  *   Edge: EdgeHTML引擎

- 渲染引擎处理网页，通常分成四个阶段
1.  解析代码：HTML代码解析为DOM，CSS代码解析为CSSOM（CSS Object Model）
2.  对象合成：将DOM和CSSOM合成一棵渲染树（render tree）
3.  布局：计算出渲染树的布局（layout）
4.  绘制：将渲染树绘制到屏幕

- 以上四步并非严格按顺序执行，往往第一步还没完成，第二步和第三步就已经开始了。所以，会看到这种情况：网页的HTML代码还没下载完，但浏览器已经显示出内容了

#### 3.2 重流和重绘
- 渲染树转换为网页布局，称为“布局流”（flow）；布局显示到页面的这个过程，称为“绘制”（paint）。它们都具有阻塞效应，并且会耗费很多时间和计算资源
- 页面生成以后，脚本操作和样式表操作，都会触发重流（reflow）和重绘（repaint）。用户的互动，也会触发，比如设置了鼠标悬停（`a:hover`）效果、页面滚动、在输入框中输入文本、改变窗口大小等等
- 重流和重绘并不一定一起发生，重流必然导致重绘，重绘不一定需要重流。比如改变元素颜色，只会导致重绘，而不会导致重流；改变元素的布局，则会导致重绘和重流
- 大多数情况下，浏览器会智能判断，将重流和重绘只限制到相关的子树上面，最小化所耗费的代价，而不会全局重新生成网页
- 作为开发者，应该尽量设法降低重绘的次数和成本。比如，尽量不要变动高层的DOM元素，而以底层DOM元素的变动代替；再比如，重绘`table`布局和`flex`布局，开销都会比较大
- 下面是一些优化技巧
  *   读取DOM或者写入DOM，尽量写在一起，不要混杂
  *   缓存DOM信息
  *   不要一项一项地改变样式，而是使用CSS class一次性改变样式
  *   使用document fragment操作DOM
  *   动画时使用absolute定位或fixed定位，这样可以减少对其他元素的影响
  *   只在必要时才显示元素
  *   使用`window.requestAnimationFrame()`，因为它可以把代码推迟到下一次重流时执行，而不是立即要求页面重流
  *   使用虚拟DOM（virtual DOM）库

#### 3.3  JavaScript引擎
- JavaScript引擎的主要作用是，读取网页中的JavaScript代码，对其处理后运行
- JavaScript是一种解释型语言，也就是说，它不需要编译，由解释器实时运行。这样的好处是运行和修改都比较方便，刷新页面就可以重新解释；缺点是每次运行都要调用解释器，系统开销较大，运行速度慢于编译型语言
- 为了提高运行速度，目前的浏览器都将JavaScript进行一定程度的编译，生成类似字节码（bytecode）的中间代码，以提高运行速度
- 早期，浏览器内部对JavaScript的处理过程如下
1.  读取代码，进行词法分析（Lexical analysis），将代码分解成词元（token）。
2.  对词元进行语法分析（parsing），将代码整理成“语法树”（syntax tree）。
3.  使用“翻译器”（translator），将代码转为字节码（bytecode）。
4.  使用“字节码解释器”（bytecode interpreter），将字节码转为机器码。

- 常见的一些JavaScript虚拟机
  - Chakra(Microsoft Internet Explorer)
  - Nitro/JavaScript Core (Safari)
  - Carakan (Opera)
  - SpiderMonkey (Firefox)
  - V8 (Chrome, Chromium)
